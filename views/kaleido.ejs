<!doctype>
<html>
<body>
<!-- START OF SNAPSHOT WITH DEPS -->
<script>
/*! snapshot - v0.1.0 - 2012-11-21
* https://github.com/twolfson/snapshot
* Copyright (c) 2012 Todd Wolfson; Licensed MIT */

/*! iframe2image - v0.1.0 - 2012-11-18
* https://github.com/twolfson/iframe2image
* Copyright (c) 2012 Todd Wolfson; Licensed MIT */

(function() {
  "use strict";

  var supportsCSSText = getComputedStyle(document.body).cssText !== "";

  function copyCSS(elem, origElem, log) {

    var computedStyle = getComputedStyle(origElem);

    if(supportsCSSText) {
      elem.style.cssText = computedStyle.cssText;

    } else {

      // Really, Firefox?
      for(var prop in computedStyle) {
        if(isNaN(parseInt(prop, 10)) && typeof computedStyle[prop] !== 'function' && !(/^(cssText|length|parentRule)$/).test(prop)) {
          elem.style[prop] = computedStyle[prop];
        }
      }

    }

  }

  function inlineStyles(elem, origElem) {

    var children = elem.querySelectorAll('*');
    var origChildren = origElem.querySelectorAll('*');

    // copy the current style to the clone
    copyCSS(elem, origElem, 1);

    // collect all nodes within the element, copy the current style to the clone
    Array.prototype.forEach.call(children, function(child, i) {
      copyCSS(child, origChildren[i]);
    });

    // strip margins from the outer element
    elem.style.margin = elem.style.marginLeft = elem.style.marginTop = elem.style.marginBottom = elem.style.marginRight = '';

  }

  window.domvas = {

    toImage: function(origElem, callback, width, height, left, top) {

      left = (left || 0);
      top = (top || 0);

      var elem = origElem.cloneNode(true);

      // inline all CSS (ugh..)
      inlineStyles(elem, origElem);

      // unfortunately, SVG can only eat well formed XHTML
      elem.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");

//       // serialize the DOM node to a String
      // var serialized = new XMLSerializer().serializeToString(elem);
// console.log(serialized);

var serialized = '<body><div style="background: blue;"><div style="background: red;">hello</div></div></body>'

      // Create well formed data URL with our DOM string wrapped in SVG
      var dataUri = "data:image/svg+xml," +
        "<svg xmlns='http://www.w3.org/2000/svg' width='" + ((width || origElem.offsetWidth) + left) + "' height='" + ((height || origElem.offsetHeight) + top) + "'>" +
          "<foreignObject width='100%' height='100%' x='" + left + "' y='" + top + "'>" +
          serialized +
          "</foreignObject>" +
        "</svg>";

      // create new, actual image
      var img = new Image();
      img.src = dataUri;

      // when loaded, fire onload callback with actual image node
      img.onload = function() {
        if(callback) {
          callback.call(this, this);
        }
      };

    }

  };

})();


(function(exports) {

  /**
   * Convert an iframe to an image
   * @param {Object|HtmlElement} params If it is an object, properties will be looked up. If it is an iframe, it will be converted into an image.
   * @param {HTMLElement} params.iframe Iframe to convert over
   * @param {Function} cb Callback to execute once iframe is converted
   * @callback arguments[0] Error if any occurred
   * @callback arguments[1] Image element of rendered content
   */
  function iframe2image(params, cb) {
    var iframe = params.iframe || params;

    // TODO: Detect if iframe has already loaded
    iframe.onload = function () {
      // Grab the body of the element
      var iframeBody = iframe.contentWindow.document.body;

      // Obtain the dimensions of the iframe
      // TODO: Cross-browser this (even though domvas uses exactly this)
      // TODO: Allow for specification of iframe dimension, body dimensions, or custom
      var iframeStyle = getComputedStyle(iframe),
          iframeHeight = parseInt(iframeStyle.height, '10'),
          iframeWidth = parseInt(iframeStyle.width, '10');

      // Convert the DOM body via domvas
      domvas.toImage(iframeBody, function (img) {
        // Callback with the image
        cb(null, img);
      }, iframeWidth, iframeHeight);
    };
  }
  exports.iframe2image = iframe2image;

}(typeof exports === 'object' && exports || this));

(function(exports) {

  /**
   * @param {String|Object} options If string, this will be the URL to take a snapshot of
   * @param {String} options.url Url to take a snapshot of
   * TODO: Options with respect to snapshot height and width
   * @param {Function} cb Function to callback snapshot with
   * @callback {Error|null} Error if there is any
   * @callback {Image} Image element containing snapshot of the URL
   */
  function snapshot(options, cb) {
    // Fallback options to a flat URL
    var url = options.url || options;

    // Create an iframe for drawing
    var iframe = document.createElement('iframe'),
        body = document.body;

    // Expand it out to 100%
    // TODO: Expand even bigger?
    iframe.height = window.innerHeight;
    iframe.width = window.innerWidth;

    // Hide the image for flicker
    iframe.style.cssText = 'display: none;';

    // Append the iframe to the DOM
    body.appendChild(iframe);

    // Load the url within the iframe
    iframe.setAttribute('src', url);

    // Convert the item to an image
    iframe2image(iframe, function (err, img) {
      // Remove the iframe
      body.removeChild(iframe);

      // Callback with result
      return cb.apply(this, arguments);
    });
  }

  // Expose snapshot
  exports.snapshot = snapshot;

}(typeof exports === 'object' && exports || this));
</script>
<!-- END OF SNAPSHOT WITH DEPS -->


<canvas id="canvas"></canvas>
<script>
  // TODO: Use CSS flex-box system or similar for SUPER easy gridding (might just grid the canvas' themself)
  // TODO The gridding system could be a repo too >_<
  (function () {

  var engines = {};

  /**
   * @param {Object} params Parameters to generate the kaleidoscope with
   * @param {Number} params.rows
   * @param {Number} params.columns
   * @param {Number} params.canvas Canvas to draw on
   * @param {String} [params.engine="snapshot"] Engine to capture screenshot via (e.g. snapshot, screenshot)
   */
  function Kaleidoscope(params) {
    // Localize params
    var canvas = params.canvas,
        rows = params.rows,
        cols = params.columns,
        enginePref = params.engine || 'snapshot',
        engine = engines[enginePref];

    // If the engine does not exist, throw an error
    if (!engine) {
      throw new Error('Kaleidoscope engine (' + enginePref + ') does not exist. You can add a new engine via Kaleidoscope.addEngine(name, fn);');
    }

    // Save rows, cols, canvas, and engine for later use
    this.rows = rows;
    this.columns = cols;
    this.canvas = canvas;
    this.context = canvas.getContext('2d');
    this.engine = engine;

    // Get the dimensions of the canvas
    var canvasDims = getComputedStyle(canvas),
        width = canvas.width,
        height = canvas.height;

    // Calculate and save the grid unit
    this.unitWidth = width / cols;
    this.unitHeight = height / rows;
    this.width = width;
    this.height = height;
  }
  Kaleidoscope.prototype = {
    // TODO: The grid should dictate the dimensions of the image we are taking a snapshot of?
    /**
     * @param {Object} position Container object for row and column
     * @param {Number} position.row Row to draw out
     * @param {Number} position.column Column to draw out
     * @param {Mixed} options Options to pass through to snapshot
     */
    'draw': function (position, options) {
      // Create an image
      var that = this,
          engine = this.engine;
      engine(options, function (err, img) {
        // If there is an error, log it
        if (err) { return console.error(err); }

        // Otherwise, calculate the position to draw the image
        var row = position.row,
            col = position.column,
            context = that.context,
            width = that.unitWidth,
            height = that.unitHeight;

        // Set up our zoom
        var zoom = 2,
            zoomWidth = width * zoom,
            zoomHeight = height * zoom;

        // Normalize down zoomWidth and height
        zoomWidth = Math.min(zoomWidth, img.width);
        zoomHeight = Math.min(zoomHeight, img.height);

        // Draw the image
        context.drawImage(img, 0, 0, zoomWidth, zoomHeight, width * col, height * row, width, height);
      });
    }
  };

  // Set up helpers for loading in engines
  function addEngine(name, fn) {
    engines[name] = fn;
  }
  Kaleidoscope.addEngine = addEngine;

  // Add in snapshot and screenshot
  // REFERENCE: options = String(url)|object(containing url, width, height)
  addEngine('snapshot', snapshot);
  addEngine('server', function (options, cb) {
    // If options is a string
    var screenshotUrl = 'http://localhost:9000',
        url = options;

    // If options is an object, extract url from it
    if (typeof options === 'object') {
      url = options.url;
    }

    // TODO: Resolve absolute vs relative URLs
    // TODO: That should probably be done by kaleidoscope (OR EVEN BETTER ANOTHER MODULE -- I think I semi-dealt with this in Resource-Collector but I am sure node-path would do a much better job)
    url = 'localhost:8080' + url;
    url = screenshotUrl + '/' + url;

    // Create an image
    var img = new Image();
    img.src = url;

    // TODO: Deal with viewport sizing and whatnot

    // When it completes loading, callback with it
    img.onload = function () {
      cb(null, img);
    };

    // If there is an error, callback with it
    img.onerror = function (err) {
      cb(err);
    }
  });

  // Expose Kaleidoscope to the window scope
  window.Kaleidoscope = Kaleidoscope;

  // Set up the canvas dimensions
  var canvas = document.getElementById('canvas'),
      innerWidth = window.innerWidth,
      innerHeight = window.innerHeight;
  canvas.width = window.innerWidth - 10;
  canvas.height = window.innerHeight - 10;

  // Create a new kaleidoscope
  var kal = new Kaleidoscope({'rows': 2, 'columns': 3, 'canvas': canvas, 'engine': 'server'});

  // Draw out the upper row
  kal.draw({'row': 0, 'column': 0}, '/');
  kal.draw({'row': 0, 'column': 1}, '/2012-11-17-subtle-anti-patterns');
  kal.draw({'row': 0, 'column': 2}, '/projects');

  // and lower row
  kal.draw({'row': 1, 'column': 0}, '/contact');
  kal.draw({'row': 1, 'column': 1}, '/contact?test=fail');
  kal.draw({'row': 1, 'column': 2}, '/404');

  }());
</script>
<script src="public/js/index.js"></script>
<!-- Load in watcher -->
<%- partial('watcher') %>
</body>
</html>